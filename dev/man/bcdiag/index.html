<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Binary Classifier · ROCKS.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://DaymondLing.github.io/ROCKS.jl/stable/man/bcdiag/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ROCKS.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User&#39;s Guide</span><ul><li class="is-active"><a class="tocitem" href>Binary Classifier</a><ul class="internal"><li><a class="tocitem" href="#kstest"><span>kstest</span></a></li><li><a class="tocitem" href="#ROC"><span>ROC</span></a></li><li><a class="tocitem" href="#bcdiag"><span>bcdiag</span></a></li><li><a class="tocitem" href="#ksplot"><span>ksplot</span></a></li><li><a class="tocitem" href="#rocplot"><span>rocplot</span></a></li><li><a class="tocitem" href="#biasplot"><span>biasplot</span></a></li><li><a class="tocitem" href="#accuracyplot"><span>accuracyplot</span></a></li><li><a class="tocitem" href="#liftcurve"><span>liftcurve</span></a></li><li><a class="tocitem" href="#cumliftcurve"><span>cumliftcurve</span></a></li><li><a class="tocitem" href="#liftable"><span>liftable</span></a></li><li><a class="tocitem" href="#cumliftable"><span>cumliftable</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../Reference/">Function Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User&#39;s Guide</a></li><li class="is-active"><a href>Binary Classifier</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Binary Classifier</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DaymondLing/ROCKS.jl/blob/master/docs/src/man/bcdiag.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Binary-classifier-performance-evaluation"><a class="docs-heading-anchor" href="#Binary-classifier-performance-evaluation">Binary classifier performance evaluation</a><a id="Binary-classifier-performance-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-classifier-performance-evaluation" title="Permalink"></a></h1><p>Whether you are building a binary classifier or need to audit one built by someone else, there are many things we&#39;d like to know about its performance. The following sections describe functions that are designed to let you easily get at commonly used binary classifier performance diagnostic metrics.</p><p>The functions are relatively performant and are capable of handling millions of rows of data.</p><h2 id="kstest"><a class="docs-heading-anchor" href="#kstest">kstest</a><a id="kstest-1"></a><a class="docs-heading-anchor-permalink" href="#kstest" title="Permalink"></a></h2><p>The two sample Kolmogorov-Smirnov test is a statistical test of whether two empirical distributions are the same. The test is based on finding the maximum separation between the two cumulative distribution functions (CDF) and determining the p-value of the test statistic.</p><p>For binary classifiers, the predicted probabilities of the two classes should be different, thus the interest isn&#39;t whether the probability distributions are different, rather, it is how large is the maximal separation and where does it occur.</p><p>Let&#39;s generate some data to illustrate the idea.</p><pre><code class="language-">using Plots
ENV[&quot;GKSwstype&quot;] = &quot;nul&quot;            # running headless turn off GR plot display
using Random, Distributions
Random.seed!(123)

n100 = rand(Normal(100, 10), 1000)
n100a = rand(Normal(100, 10), 1000)
n120 = rand(Normal(120, 10), 1000)
n140 = rand(Normal(140, 10), 1000)

histogram(n100, nbins = 50, opacity= 0.3)
histogram!(n100a, nbins = 50, opacity= 0.3, legend = nothing)
savefig(&quot;kstest-1.svg&quot;); nothing # hide</code></pre><p><img src="kstest-1.svg" alt/></p><p>We can use the <code>kstest</code> function to find the maximum separation and its location. The required input is a vector designating the two classes and another vector of the values, this is the typical data structure of model scoring on development or validation data.</p><pre><code class="language-">using ROCKS

cls = [fill(0, length(n100)); fill(1, length(n100a))]
values = [n100; n100a]
kstest(cls, values)</code></pre><p><code>kstest</code> returns results in a named tuple:</p><ul><li><code>n</code>, total number of observations</li><li><code>n1</code>, total number of observations in class 1</li><li><code>n0</code>, total number of observations in class 0</li><li><code>baserate</code>, n1 / n, the incidence rate of class 1</li><li><code>ks</code>, the maximum separation between CDF1 and CDF0, a value between [0, 1]</li><li><code>ksarg</code>, argmax, the value where maximum separation is achieved</li><li><code>ksdep</code>, depth of argmax in the sorted values (default sort is from high to low)</li></ul><p>ks of 0 means the distributions are indistinguishable, ks of 1 says the two distributions are complete separable. These two distributions have negligible separation since they are drawn from the same distribution.</p><p>We now test on moderate separation:</p><pre><code class="language-">histogram(n100, nbins = 50, opacity= 0.3)
histogram!(n120, nbins = 50, opacity= 0.3, legend = nothing)
savefig(&quot;kstest-2.svg&quot;); nothing    # hide</code></pre><p><img src="kstest-2.svg" alt/></p><pre><code class="language-">cls = [fill(0, length(n100)); fill(1, length(n120))]
values = [n100; n120]
kstest(cls, values)</code></pre><p>There&#39;s considerable separation between the classes, and ks is larger than before.</p><p>Let&#39;s test on widely separately data:</p><pre><code class="language-">histogram(n100, nbins = 50, opacity= 0.3)
histogram!(n140, nbins = 50, opacity= 0.3, legend = nothing)
savefig(&quot;kstest-3.svg&quot;); nothing    # hide</code></pre><p><img src="kstest-3.svg" alt/></p><pre><code class="language-">cls = [fill(0, length(n100)); fill(1, length(n140))]
values = [n100; n140]
kstest(cls, values)</code></pre><p>We can see that the two classes are nearly separable and ks is now quite high at 0.949. These examples illustrate how <code>ks</code> can serve as an indicator of the ability to separate the two classes.</p><h2 id="ROC"><a class="docs-heading-anchor" href="#ROC">ROC</a><a id="ROC-1"></a><a class="docs-heading-anchor-permalink" href="#ROC" title="Permalink"></a></h2><p>A good binary classifier would have high sensitivity (able to recognize True Positive) and high specificity (able to recognize True Negatives, hence have low False Positive). A plot of the trade-off curve of True Positive Rate versus False Positive Rate at various cutoff probabilities is called the Receiver Operating Characteristics (ROC) curve. One way to quantify performance is by the area under the ROC curve, often abbreviated as AUC or C, many packages would compute AUC via numeric integration of the ROC curve. AUC is in the range [0, 1], a perfect model has AUC of 1, a random model has AUC of 0.5, and a perfectly backwards model would have AUC of -1.</p><p>There is another interpretation of AUC which provides more intuition than simply as the area under a curve. If we make all possible pair-wise comparisons between the probabilities of class 1 with class 0, we can count the incidences of:</p><ul><li>Concordant: class 1 probability &gt; class 0 probability</li><li>Tied: class 1 probability ≈ class 0 probability</li><li>Discordant: class 1 probability &lt; class 0 probability</li></ul><p>Then we can compute:</p><ul><li>AUC: (Concordant + 0.5 Tied) / (N1 * N0)</li><li>Gini: 2AUC - 1, or (Concordant - Discordant) / (N1 * N0)</li><li>Goodman-Kruskal Gamma: (Concordant - Discordant) / (Concordant + Discordant), no penalty for Tied</li><li>Kendall&#39;s Tau: (Concordant - Discordant) / (0.5 * (N1+N0) * (N1+N0-1))</li></ul><p>We can interpret AUC as the percentage of time class 1 probabilities is larger than class 0 probabilities (ignoring ties).</p><p>The mathematical proof can be found at <a href="https://stats.stackexchange.com/questions/180638/how-to-derive-the-probabilistic-interpretation-of-the-auc">Stack Exchange</a> and <a href="https://pdfs.semanticscholar.org/1fcb/f15898db36990f651c1e5cdc0b405855de2c.pdf">Professor David J. Hand&#39;s article</a>.</p><pre><code class="language-">cls = [fill(0, length(n100)); fill(1, length(n140))]
values = [n100; n140]
roc(cls, values)</code></pre><p><code>roc</code> returns results in a named tuple:</p><ul><li><code>conc</code>, number of concordant comparisons</li><li><code>tied</code>, number of tied comparisons</li><li><code>disc</code>, number of discordant comparisons</li><li><code>auc</code>, area under ROC curve, or just area under curve</li><li><code>gini</code>, 2auc - 1</li></ul><h2 id="bcdiag"><a class="docs-heading-anchor" href="#bcdiag">bcdiag</a><a id="bcdiag-1"></a><a class="docs-heading-anchor-permalink" href="#bcdiag" title="Permalink"></a></h2><p>While <code>kstest</code> and <code>roc</code> provide diagnostic measures for comparing model performance, when there is a model of interest, it is likely that we need to produce many graphs and table to understand and document its performance, <code>bcdiag</code> allows us to do this easily.</p><pre><code class="language-">using ROCKS
using Random
using GLM
using DataFrames

function logitgen(intercept::Real, slope::Real, len::Int; seed = 888)
    Random.seed!(seed)
    x = 10 .* rand(len)                     # random uniform [0, 10)
    # sort!(x)                                # x ascending
    logit = @. intercept + slope * x        # logit(prob) = ln(p / (1 + p)) = linear equation
    prob = @. 1. / (1. + exp(-logit))       # probability
    y = rand(len) .&lt;= prob
    y, x
end

y, x = logitgen(-3, 0.6, 100_000)

m = DataFrame(target=y, x=x)
m_logistic = glm(@formula(target ~ x), m, Binomial(), LogitLink())
m.pred = predict(m_logistic)

kstest(m.target, m.pred)</code></pre><pre><code class="language-">roc(m.target, m.pred)</code></pre><p>Running <code>bcdiag</code> prints a quick summary:</p><pre><code class="language-">mdiag = bcdiag(m.target, m.pred)</code></pre><p>The output structure allows us to create the following plots and tables to understand:</p><ul><li>the ability of the model to separate the two classes</li><li>the accuracy of the probability point estimates</li><li>how to set cutoff for maximum accuracy</li><li>performance of the model at varying cutoff depth</li></ul><h2 id="ksplot"><a class="docs-heading-anchor" href="#ksplot">ksplot</a><a id="ksplot-1"></a><a class="docs-heading-anchor-permalink" href="#ksplot" title="Permalink"></a></h2><p><code>ksplot</code> plots the cumulative distribution of class 1 (true positive rate) and class 0 (false positive rate) versus depth.</p><pre><code class="language-">ksplot(mdiag)
savefig(&quot;bcd-ksplot.svg&quot;); nothing # hide</code></pre><p>It shows where the maximum separation of the two distributions occur.</p><p><img src="bcd-ksplot.svg" alt/></p><h2 id="rocplot"><a class="docs-heading-anchor" href="#rocplot">rocplot</a><a id="rocplot-1"></a><a class="docs-heading-anchor-permalink" href="#rocplot" title="Permalink"></a></h2><p><code>rocplot</code> plots the true positive rate vs. false positive rate (depth is implicit).</p><pre><code class="language-">rocplot(mdiag)
savefig(&quot;bcd-rocplot.svg&quot;); nothing # hide</code></pre><p>A perfect model has auc of 1, a random model has auc of 0.5.</p><p><img src="bcd-rocplot.svg" alt/></p><h2 id="biasplot"><a class="docs-heading-anchor" href="#biasplot">biasplot</a><a id="biasplot-1"></a><a class="docs-heading-anchor-permalink" href="#biasplot" title="Permalink"></a></h2><p>Both <code>ksplot</code> and <code>rocplot</code> rely on the ability of the model to rank order the observations, the score value itself doesn&#39;t matter. For example, if you took the score and perform any monotonic transform, <code>ks</code> and <code>auc</code> wouldn&#39;t change. There are occasions where the score value does matter, where the probabilities need to be accurate, for example, in expected return calculations. Thus, we need to understand whether the probabilities are accurate, <code>biasplot</code> does this by plotting the observed response rate versus predicted response rate to look for systemic bias. This is also called the <em>calibration</em> graph.</p><pre><code class="language-">biasplot(mdiag)
savefig(&quot;bcd-biasplot.svg&quot;); nothing # hide</code></pre><p><img src="bcd-biasplot.svg" alt/></p><p>An unbiased model would lie on the diagnonal, systemic shift off the diagonal represents over or under estimate of the true probability.</p><h2 id="accuracyplot"><a class="docs-heading-anchor" href="#accuracyplot">accuracyplot</a><a id="accuracyplot-1"></a><a class="docs-heading-anchor-permalink" href="#accuracyplot" title="Permalink"></a></h2><p>People often refer to <strong>(TP + TN) / N</strong> as accuracy of the model, that is, the ability to correctly identify correct cases. It is used to compare model performance as well - model with higher accuracy is a better model. For a probability based classifier, a cutoff is required to turn probability to predicted class. So, what is the cutoff value to use to achieve maximum accuracy?</p><p>There are many approaches to setting the best cutoff, one way is to assign utility values to the four outcomes of [TP, FP, FN, TN] and maximize the sum across different cutoff&#39;s. Accuracy measure uses the utility values of [1, 0, 0, 1] giving TP + TN. You can assign negative penalty terms for misclassification as well.</p><p>Note that this is different from <code>kstest</code> - maximum separation on cumulative distribution (normalized to 100%) does not account for class size difference, e.g., class 1 may be only 2% of the cases.</p><pre><code class="language-">accuracyplot(mdiag)
savefig(&quot;bcd-accuracyplot.svg&quot;); nothing # hide</code></pre><p><img src="bcd-accuracyplot.svg" alt/></p><h2 id="liftcurve"><a class="docs-heading-anchor" href="#liftcurve">liftcurve</a><a id="liftcurve-1"></a><a class="docs-heading-anchor-permalink" href="#liftcurve" title="Permalink"></a></h2><p><code>liftcurve</code> plots the actual response and predicted response versus depth, with baserate as 1.</p><pre><code class="language-">liftcurve(mdiag)
savefig(&quot;bcd-liftcurve.svg&quot;); nothing # hide</code></pre><p>We can easily see where the model is performing better than average, approximately the same as average, or below average.</p><p><img src="bcd-liftcurve.svg" alt/></p><h2 id="cumliftcurve"><a class="docs-heading-anchor" href="#cumliftcurve">cumliftcurve</a><a id="cumliftcurve-1"></a><a class="docs-heading-anchor-permalink" href="#cumliftcurve" title="Permalink"></a></h2><p><code>cumliftcurve</code> is similar to <code>liftcurve</code>, the difference is it is a plot of <em>cumulative</em> response rate from the top of the model.</p><pre><code class="language-">cumliftcurve(mdiag)
savefig(&quot;bcd-cumliftcurve.svg&quot;); nothing # hide</code></pre><p><img src="bcd-cumliftcurve.svg" alt/></p><h2 id="liftable"><a class="docs-heading-anchor" href="#liftable">liftable</a><a id="liftable-1"></a><a class="docs-heading-anchor-permalink" href="#liftable" title="Permalink"></a></h2><p><code>liftable</code> is the table from which <code>liftcurve</code> is plotted.</p><pre><code class="language-">liftable(mdiag)</code></pre><h2 id="cumliftable"><a class="docs-heading-anchor" href="#cumliftable">cumliftable</a><a id="cumliftable-1"></a><a class="docs-heading-anchor-permalink" href="#cumliftable" title="Permalink"></a></h2><p><code>cumliftable</code> is the <em>cumulative</em> version of <code>liftable</code>.</p><pre><code class="language-">cumliftable(mdiag)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../../Reference/">Function Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 26 June 2021 20:39">Saturday 26 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
